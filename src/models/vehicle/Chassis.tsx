import debounce from 'lodash-es/debounce'
import clamp from 'lodash-es/clamp'
import {forwardRef, useRef, useCallback, useEffect, useLayoutEffect, useImperativeHandle} from 'react'
import { useBox } from '@react-three/cannon'
import { useGLTF } from '@react-three/drei'
import { useFrame } from '@react-three/fiber'
import {Color, Vector3, MathUtils, MeshPhysicalMaterial, Quaternion, Raycaster, Matrix4} from 'three'

import type { PropsWithChildren } from 'react'
import type { BoxProps } from '@react-three/cannon'
import type { GLTF } from 'three-stdlib'
import type { BoxBufferGeometry, Group, Mesh, MeshStandardMaterial, PositionalAudio as PositionalAudioImpl } from 'three'
import type { CollideEvent } from '@react-three/cannon'

import { getState, setState, mutation, useStore } from '../../store'

import type { Camera, Controls } from '../../store'

const { lerp } = MathUtils
const RESPAWN_YAW_OFFSET = Math.PI / 2

/*
Initially generated by: https://github.com/pmndrs/gltfjsx
author: Alexus16 (https://sketchfab.com/Alexus16)
license: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
source: https://sketchfab.com/3d-models/classic-muscle-car-641efc889e5f4543bae51d0922e6f4b3
title: Classic Muscle car
*/

interface ChassisGLTF extends GLTF {
  nodes: {
    Cube001: Mesh
    Scene: Group
    Truck_Brakesys: Group
    Truck_Brakesys_1: Mesh
    Truck_Brakesys_2: Mesh
    Truck_Fueltank01: Mesh
    Truck_Fueltank02: Mesh
    Truck_Toolbox: Mesh
    Truck_Toolbox1: Group
    Truck_Toolbox1_1: Mesh
    Truck_Toolbox1_2: Mesh
    Truck_Toolbox1_3: Mesh
    Truck_backmirrorL: Group
    Truck_backmirrorL_1: Mesh
    Truck_backmirrorL_2: Mesh
    Truck_backmirrorL_3: Mesh
    Truck_backmirrorR: Group
    Truck_backmirrorR_1: Mesh
    Truck_backmirrorR_2: Mesh
    Truck_body_Truck_bodyL: Group
    Truck_body_Truck_bodyL_1: Mesh
    Truck_body_Truck_bodyL_2: Mesh
    Truck_body_Truck_bodyL_3: Mesh
    Truck_body_Truck_bodyL_4: Mesh
    Truck_body_Truck_bodyL_5: Mesh
    Truck_body_Truck_bodyL_6: Mesh
    Truck_body_Truck_bodyL_7: Mesh
    Truck_doorL: Group
    Truck_doorL_1: Mesh
    Truck_doorL_2: Mesh
    Truck_doorL_3: Mesh
    Truck_doorL_4: Mesh
    Truck_doorR: Group
    Truck_doorR_1: Mesh
    Truck_doorR_2: Mesh
    Truck_doorR_3: Mesh
    Truck_doorR_4: Mesh
    Truck_head_Truck_headL: Group
    Truck_head_Truck_headL_1: Mesh
    Truck_head_Truck_headL_2: Mesh
    Truck_head_Truck_headL_3: Mesh
    Truck_head_Truck_headL_4: Mesh
    Truck_head_Truck_headL_5: Mesh
    Truck_head_Truck_headL_6: Mesh
    Truck_head_Truck_headL_7: Mesh
    Truck_head_Truck_headL_8: Mesh
    Truck_head_Truck_headL_9: Mesh
    Truck_head_Truck_headL_10: Mesh
    Truck_head_Truck_headL_11: Mesh
    Truck_head_Truck_headL_12: Mesh
    wheel_Circle001: Group
    wheel_Circle001_1: Mesh
    wheel_Circle001_2: Mesh
    wheel_Circle001_3: Mesh
    // wheels_Circle: Group
    // wheels_Circle_1: Mesh
    // wheels_Circle_2: Mesh
    // wheels_Circle_3: Mesh
    // Cube001: Mesh
    //     Scene: Group
    //     Truck_backmirrorL: Group
    //     Truck_backmirrorL001: Mesh
    //     Truck_backmirrorL001_1: Mesh
    //     Truck_backmirrorL001_2: Mesh
    //     Truck_backmirrorR: Group
    //     Truck_backmirrorR001: Mesh
    //     Truck_backmirrorR001_1: Mesh
    //     Truck_body_Truck_bodyL: Group
    //     Truck_body_Truck_bodyL001: Mesh
    //     Truck_body_Truck_bodyL001_1: Mesh
    //     Truck_body_Truck_bodyL001_2: Mesh
    //     Truck_body_Truck_bodyL001_3: Mesh
    //     Truck_body_Truck_bodyL001_4: Mesh
    //     Truck_body_Truck_bodyL001_5: Mesh
    //     Truck_body_Truck_bodyL001_6: Mesh
    //     Truck_doorL: Group
    //     Truck_doorL001: Mesh
    //     Truck_doorL001_1: Mesh
    //     Truck_doorL001_2: Mesh
    //     Truck_doorL001_3: Mesh
    //     Truck_doorR: Group
    //     Truck_doorR001: Mesh
    //     Truck_doorR001_1: Mesh
    //     Truck_doorR001_2: Mesh
    //     Truck_doorR001_3: Mesh
    //     Truck_head_Truck_headL: Group
    //     Truck_head_Truck_headL001: Mesh
    //     Truck_head_Truck_headL001_1: Mesh
    //     Truck_head_Truck_headL001_2: Mesh
    //     Truck_head_Truck_headL001_3: Mesh
    //     Truck_head_Truck_headL001_4: Mesh
    //     Truck_head_Truck_headL001_5: Mesh
    //     Truck_head_Truck_headL001_6: Mesh
    //     Truck_head_Truck_headL001_7: Mesh
    //     Truck_head_Truck_headL001_8: Mesh
    //     Truck_head_Truck_headL001_9: Mesh
    //     Truck_head_Truck_headL001_10: Mesh
    //     Truck_head_Truck_headL001_11: Mesh
    //     wheels_Circle: Group
    //     wheels_Circle001: Mesh
    //     wheels_Circle001_1: Mesh
    //     wheels_Circle003: Mesh
    //     wheels_Circle004: Mesh
    //     wheels_Circle004_1: Mesh
    //     wheels_Circle010: Group
    //     wheels_Circle013: Mesh
    //     wheels_Circle020: Mesh
    //     wheels_Circle021: Mesh
    //     wheels_Circle022: Mesh
    //     wheels_Circle023: Mesh
    //     wheels_Circle024: Mesh
    //     wheels_Circle025: Mesh
    //     wheels_Circle026: Mesh
    //     wheels_Circle027: Mesh
    //     wheels_Circle028: Mesh
    //     wheels_Circle041: Mesh
    //     wheels_Circle044: Mesh
    //     wheels_Circle045: Mesh
    //     wheels_Circle046: Mesh
    //     wheels_Circle047: Mesh
    //     wheels_Circle048: Mesh
    //     wheels_Circle049: Mesh
    //     wheels_Circle050: Mesh
    //     wheels_Circle051: Mesh
    //     wheels_Circle052: Mesh
    //     wheels_Circle065: Mesh
    //     wheels_Circle068: Mesh
    //     wheels_Circle070: Mesh
  }
  materials: {
    BodyPaint: MeshPhysicalMaterial
    License: MeshStandardMaterial
    Chassis_2: MeshStandardMaterial
    Glass: MeshStandardMaterial
    BrakeLight: MeshStandardMaterial
    defaultMatClone: MeshStandardMaterial
    HeadLight: MeshStandardMaterial
    Black: MeshStandardMaterial
    Undercarriage: MeshStandardMaterial
    TurnSignal: MeshStandardMaterial
  }
}

type MaterialMesh = Mesh<BoxBufferGeometry, MeshStandardMaterial>

const gears = 10
const c = new Color()
const v = new Vector3()

export const Chassis = forwardRef<Group, PropsWithChildren<BoxProps>>(({ args = [1.2, 0.6, 4.7], mass = 500, children, ...props }, ref) => {
  const glass = useRef<MaterialMesh>(null!)
  const brake = useRef<MaterialMesh>(null!)
  const wheel = useRef<Group>(null)
  const needle = useRef<MaterialMesh>(null!)
  const chassis_1 = useRef<MaterialMesh>(null!)
  const crashAudio = useRef<PositionalAudioImpl>(null!)
  const chassisRef = useRef<Group>(null!)
  useImperativeHandle(ref, () => chassisRef.current!,[])

  const bodyQuat = useRef(new Quaternion())
  const bodyPos = useRef(new Vector3())

  const tippedTimer = useRef(0)
  const fallTimer = useRef(0)
  const respawnCooldown = useRef(0)

  const tmpUp = new Vector3()
  const worldUp = new Vector3(0,1,0)
  const ray = useRef(new Raycaster())

  const [maxSpeed] = useStore((s) => [s.vehicleConfig.maxSpeed])
  const { nodes: n, materials: m } = useGLTF('/models/chassis-draco1.glb') as ChassisGLTF
    // console.log(n, m)

    const onCollide = useCallback(
        debounce<(e: CollideEvent) => void>((e) => {
            e.target.position.set(0,0,0)
            if (e.body.userData.trigger || !getState().sound || !crashAudio.current) return
            crashAudio.current.setVolume(clamp(e.contact.impactVelocity / 10, 0.2, 1))
            if (!crashAudio.current.isPlaying) crashAudio.current.play()
        }, 200),
        [],
    )

    const [, api] = useBox(() => ({ mass, args, allowSleep: false, onCollide, linearDamping: 0.06, angularDamping: 0.2, ...props }), chassisRef)

    useEffect(() => {
        setState({ api })
        return () => setState({ api: null })
    }, [api])

    useEffect(() => {
        const launchV = 7
        const node = chassisRef.current
        if(node){
            const forward = new Vector3(0,0,-1).applyQuaternion(node.quaternion)
            api.velocity.set(forward.x * launchV, 0, forward.z * launchV)
        }
    }, []);

    useEffect(() => {
        const unsubQ = api.quaternion.subscribe(([x,y,z,w]) => bodyQuat.current.set(x,y,z,w))
        const unsubP = api.position.subscribe(([x,y,z]) => bodyPos.current.set(x,y,z))

        return () => {
            unsubQ()
            unsubP()
        }
    }, [api]);

    useEffect(() => {
  const api = getState().api
  if (!api) return
  let last = 0
  const unsub = api.position.subscribe(([x, y, z]) => {
    const now = performance.now()
    if (now - last > 250) { // log ~4x/sec
      console.log(`[POS] x=${x.toFixed(2)} y=${y.toFixed(2)} z=${z.toFixed(2)}`)
      last = now
    }
  })
  return () => { unsub() }
}, [])

    useLayoutEffect(
        () =>
            api.velocity.subscribe((velocity) => {
                const speed = v.set(...velocity).length()
                const gearPosition = speed / (maxSpeed / gears)
                const rpmTarget = Math.max(((gearPosition % 1) + Math.log(gearPosition)) / 6, 0)
                Object.assign(mutation, { rpmTarget, speed, velocity })
            }),
        [maxSpeed],
    )

  let camera: Camera
  let controls: Controls
    useFrame((_, delta) => {
        camera = getState().camera
        controls = getState().controls

        respawnCooldown.current = Math.max(0, respawnCooldown.current-delta)

        const s = mutation.speed
        const downforce = Math.min(s*s*0.03,200)
        api.applyForce([0,-downforce,0], [0,0,0])

        if (wheel.current) wheel.current.rotation.z = lerp(wheel.current.rotation.z, controls.left ? -Math.PI : controls.right ? Math.PI : 0, delta)
        needle.current.rotation.y = (mutation.speed / maxSpeed) * -Math.PI * 2 - 0.9
        chassis_1.current.material.color.lerp(c.set(getState().color), 0.1)

        // --- Tip-over & fall detection -> respawn (ground-aware, parallel to track) ---
{
  // 1 upright, 0 side, -1 upside-down
  const uprightDot = tmpUp.set(0, 1, 0).applyQuaternion(bodyQuat.current).dot(worldUp)
  const isTipped = uprightDot < 0.35
  const isSlow = s < 6.0
  const belowTrack = bodyPos.current.y < -1.0
  const canRespawn = respawnCooldown.current <= 0

  tippedTimer.current = canRespawn && isTipped && isSlow ? tippedTimer.current + delta : 0
  fallTimer.current   = canRespawn && belowTrack         ? fallTimer.current + delta   : 0

  if (tippedTimer.current >= 3.0 || fallTimer.current >= 1.5) {
    const { lastCheckpoint, level } = getState()
    const [cx, cy, cz] = lastCheckpoint.position
    const ry = lastCheckpoint.rotationY

    // Move a bit along the TRACK direction (ry) so we don't re-touch the gate
    const trackForward = new Vector3(0, 0, -1).applyAxisAngle(new Vector3(0, 1, 0), ry)
    const target = new Vector3(cx, cy, cz).addScaledVector(trackForward, 2.2)

    // Raycast to get road height + normal
    const castHeight = 50
    const upOffset = 0.7
    const levelGroup = level?.current || null
    let normalWorld = worldUp.clone()

    if (levelGroup) {
      ray.current.set(target.clone().addScaledVector(worldUp, castHeight), worldUp.clone().multiplyScalar(-1))
      const hit = ray.current.intersectObject(levelGroup, true)[0]
      if (hit) {
        target.copy(hit.point).addScaledVector(worldUp, upOffset)
        if (hit.face) {
          normalWorld = hit.face.normal.clone().transformDirection(hit.object.matrixWorld).normalize()
        }
      } else {
        target.y += upOffset
      }
    } else {
      target.y += upOffset
    }

    // Safety: if we hit a wall (too steep), use world up so the truck is never horizontal
    if (normalWorld.dot(worldUp) < 0.6) normalWorld.copy(worldUp)

    // Align UP to road normal…
    const qAlign = new Quaternion().setFromUnitVectors(worldUp, normalWorld)
    // …then yaw around that normal by the track heading + model fix
    const heading = ry + RESPAWN_YAW_OFFSET
    const qYaw = new Quaternion().setFromAxisAngle(normalWorld, heading)
    const qFinal = qYaw.multiply(qAlign)

    // Zero motion
    api.velocity.set(0, 0, 0)
    api.angularVelocity.set(0, 0, 0)

    // Teleport & orient
    api.position.set(target.x, target.y, target.z)
    api.quaternion.set(qFinal.x, qFinal.y, qFinal.z, qFinal.w)

    // Small roll-away nudge strictly ALONG THE TRACK (not model axis)
    const nudgeDir = trackForward.clone().sub(normalWorld.clone().multiplyScalar(trackForward.dot(normalWorld))).normalize()
    api.velocity.set(nudgeDir.x * 2.0, 0, nudgeDir.z * 2.0)

    // Reset & cooldown
    tippedTimer.current = 0
    fallTimer.current = 0
    respawnCooldown.current = 1.0
  }
}


    })



  return (
    <group ref={chassisRef} dispose={null}>
      <group position={[0,-0.7, 0]} scale={[0.5, 0.5, 0.5]} rotation={[0,0,0]}>
        <mesh ref={chassis_1} castShadow receiveShadow geometry={n.Cube001.geometry} material={m.BodyPaint} material-color="black" />
        <mesh castShadow geometry={n.Cube001.geometry} material={n.Cube001.material} material-color="black" />
        <mesh castShadow geometry={n.Truck_Brakesys_1.geometry} material={n.Truck_Brakesys_1.material} material-color="black" />
        <mesh castShadow geometry={n.Truck_Brakesys_2.geometry} material={n.Truck_Brakesys_2.material} material-color="black" />
        <mesh castShadow geometry={n.Truck_Fueltank01.geometry} material={n.Truck_Fueltank01.material} material-color="red" />
        <mesh castShadow geometry={n.Truck_Fueltank02.geometry} material={n.Truck_Fueltank02.material} material-color="red" />
        <mesh castShadow geometry={n.Truck_Toolbox.geometry} material={n.Truck_Toolbox.material} material-color="black" />
        <mesh castShadow geometry={n.Truck_Toolbox1_1.geometry} material={n.Truck_Toolbox1_1.material} material-color="black" />
        <mesh castShadow geometry={n.Truck_Toolbox1_2.geometry} material={n.Truck_Toolbox1_2.material} material-color="pink" />
        <mesh castShadow geometry={n.Truck_Toolbox1_3.geometry} material={n.Truck_Toolbox1_3.material} material-color="pink" />
        <mesh castShadow geometry={n.Truck_backmirrorL_1.geometry} material={n.Truck_backmirrorL_1.material} material-color="pink" />
        <mesh castShadow geometry={n.Truck_backmirrorL_2.geometry} material={n.Truck_backmirrorL_2.material} material-color="pink" />
        <mesh castShadow geometry={n.Truck_backmirrorL_3.geometry} material={n.Truck_backmirrorL_3.material} material-color="pink" />
        <mesh castShadow geometry={n.Truck_backmirrorR_1.geometry} material={n.Truck_backmirrorR_1.material} material-color="pink" />
        <mesh castShadow geometry={n.Truck_backmirrorR_2.geometry} material={n.Truck_backmirrorR_2.material} material-color="pink" />
        <mesh castShadow geometry={n.Truck_body_Truck_bodyL_1.geometry} material={n.Truck_body_Truck_bodyL_1.material} material-color="pink" />
        <mesh castShadow geometry={n.Truck_body_Truck_bodyL_2.geometry} material={n.Truck_body_Truck_bodyL_2.material} material-color="pink" />
        <mesh castShadow geometry={n.Truck_body_Truck_bodyL_3.geometry} material={n.Truck_body_Truck_bodyL_3.material} material-color="pink" />
        <mesh castShadow geometry={n.Truck_body_Truck_bodyL_4.geometry} material={n.Truck_body_Truck_bodyL_4.material} material-color="pink" />
        <mesh castShadow geometry={n.Truck_body_Truck_bodyL_5.geometry} material={n.Truck_body_Truck_bodyL_5.material} material-color="pink" />
        <mesh castShadow geometry={n.Truck_body_Truck_bodyL_6.geometry} material={n.Truck_body_Truck_bodyL_6.material} material-color="pink" />
        <mesh castShadow geometry={n.Truck_body_Truck_bodyL_7.geometry} material={n.Truck_body_Truck_bodyL_7.material} material-color="pink" />
        <mesh castShadow geometry={n.Truck_doorL_1.geometry} material={n.Truck_doorL_1.material} material-color="pink" />
        <mesh castShadow geometry={n.Truck_doorL_2.geometry} material={n.Truck_doorL_2.material} material-color="pink" />
        <mesh castShadow geometry={n.Truck_doorL_3.geometry} material={n.Truck_doorL_3.material} material-color="pink" />
        <mesh castShadow geometry={n.Truck_doorL_4.geometry} material={n.Truck_doorL_4.material} material-color="pink" />
        <mesh castShadow geometry={n.Truck_doorR_1.geometry} material={n.Truck_doorR_1.material} material-color="pink" />
        <mesh castShadow geometry={n.Truck_doorR_2.geometry} material={n.Truck_doorR_2.material} material-color="pink" />
        <mesh castShadow geometry={n.Truck_doorR_3.geometry} material={n.Truck_doorR_3.material} material-color="pink" />
        <mesh castShadow geometry={n.Truck_doorR_4.geometry} material={n.Truck_doorR_4.material} material-color="pink" />
        <mesh castShadow geometry={n.Truck_head_Truck_headL_1.geometry} material={n.Truck_head_Truck_headL_1.material} material-color="#CED1F8" />
        <mesh castShadow geometry={n.Truck_head_Truck_headL_2.geometry} material={n.Truck_head_Truck_headL_2.material} material-color="#CED1F8" />
        <mesh castShadow geometry={n.Truck_head_Truck_headL_3.geometry} material={n.Truck_head_Truck_headL_3.material} material-color="#CED1F8" />
        <mesh castShadow geometry={n.Truck_head_Truck_headL_4.geometry} material={n.Truck_head_Truck_headL_4.material} material-color="#CED1F8" />
        <mesh castShadow geometry={n.Truck_head_Truck_headL_5.geometry} material={n.Truck_head_Truck_headL_5.material} material-color="#CED1F8" />
        <mesh castShadow geometry={n.Truck_head_Truck_headL_6.geometry} material={n.Truck_head_Truck_headL_6.material} material-color="#CED1F8" />
        <mesh castShadow geometry={n.Truck_head_Truck_headL_7.geometry} material={n.Truck_head_Truck_headL_7.material} material-color="#CED1F8" />
        <mesh castShadow geometry={n.Truck_head_Truck_headL_8.geometry} material={n.Truck_head_Truck_headL_8.material} material-color="black" />
        <mesh castShadow geometry={n.Truck_head_Truck_headL_9.geometry} material={n.Truck_head_Truck_headL_9.material} material-color="black" />
        <mesh castShadow geometry={n.Truck_head_Truck_headL_10.geometry} material={n.Truck_head_Truck_headL_10.material} material-color="black" />
        <mesh castShadow geometry={n.Truck_head_Truck_headL_11.geometry} material={n.Truck_head_Truck_headL_11.material} material-color="black" />
        <mesh castShadow geometry={n.Truck_head_Truck_headL_12.geometry} material={n.Truck_head_Truck_headL_12.material} material-color="black" />

        <mesh castShadow geometry={n.wheel_Circle001_1.geometry} material={n.wheel_Circle001_1.material} material-color="pink" position={[0,1,0]} />
        <mesh castShadow geometry={n.wheel_Circle001_2.geometry} material={n.wheel_Circle001_2.material} material-color="pink" position={[0,1,0]} />
        <mesh castShadow geometry={n.wheel_Circle001_3.geometry} material={n.wheel_Circle001_3.material} material-color="pink" position={[0,1,0]}/>
        {/*<mesh castShadow geometry={n.wheels_Circle_1.geometry} material={n.wheels_Circle_1.material} material-color="pink" />*/}
        {/*<mesh castShadow geometry={n.wheels_Circle_2.geometry} material={n.wheels_Circle_2.material} material-color="pink" />*/}
        {/*<mesh castShadow geometry={n.wheels_Circle_3.geometry} material={n.wheels_Circle_3.material} material-color="pink" />*/}

        <mesh position={[1, 0.3045, 0.6536]} rotation={[Math.PI / 2, -1.1954, 0]} scale={[0.0209, 0.0209, 0.0209]} />
        <mesh ref={needle} position={[1, 0.3045, 0.6536]} rotation={[-Math.PI / 2, -0.9187, Math.PI]} scale={[0.0209, 0.0209, 0.0209]} />
      </group>
      {children}
    </group>
  )
})

//
// return (
//   <group ref={ref} dispose={null}>
//     <group position={[0, -0.2, -0.2]}>
//       <mesh ref={chassis_1} castShadow receiveShadow geometry={n.Chassis_1.geometry} material={m.BodyPaint} material-color="#f0c050" />
//       <mesh castShadow geometry={n.Chassis_2.geometry} material={m.BodyPaint} material-color="#353535" />
//       <mesh castShadow ref={glass} geometry={n.Glass.geometry} material={m.BodyPaint} material-transparent />
//       <mesh ref={brake} geometry={n.BrakeLights.geometry} material={m.BodyPaint} material-transparent />
//       <mesh geometry={n.HeadLights.geometry} material={m.BodyPaint} />
//       <mesh geometry={n.Cabin_Grilles.geometry} material={m.BodyPaint} />
//       <mesh geometry={n.Undercarriage.geometry} material={m.BodyPaint} />
//       <mesh geometry={n.TurnSignals.geometry} material={m.BodyPaint} />
//       <mesh geometry={n.Chrome.geometry} material={n.Chrome.material} />
//       <group ref={wheel} position={[0.37, 0.25, 0.46]}>
//         <mesh geometry={n.Wheel_1.geometry} material={n.Wheel_1.material} />
//         <mesh geometry={n.Wheel_2.geometry} material={n.Wheel_2.material} />
//       </group>
//       <group position={[0, 0, 0]}>
//         <mesh geometry={n.License_1.geometry} material={m.License} />
//         <mesh geometry={n.License_2.geometry} material={n.License_2.material} />
//       </group>
//       <group position={[0.2245, 0.3045, 0.6806]} scale={[0.0594, 0.0594, 0.0594]}>
//         <mesh geometry={n.Cube013.geometry} material={n.Cube013.material} />
//         <mesh geometry={n.Cube013_1.geometry} material={n.Cube013_1.material} />
//         <mesh geometry={n.Cube013_2.geometry} material={n.Cube013_2.material} />
//       </group>
//       <mesh
//         geometry={n['pointer-left'].geometry}
//         material={n['pointer-left'].material}
//         position={[0.5107, 0.3045, 0.6536]}
//         rotation={[Math.PI / 2, -1.1954, 0]}
//         scale={[0.0209, 0.0209, 0.0209]}
//       />
//       <mesh
//         ref={needle}
//         geometry={n['pointer-right'].geometry}
//         material={n['pointer-right'].material}
//         position={[0.2245, 0.3045, 0.6536]}
//         rotation={[-Math.PI / 2, -0.9187, Math.PI]}
//         scale={[0.0209, 0.0209, 0.0209]}
//       />
//     </group>
//     {children}
//     <PositionalAudio ref={crashAudio} url="/sounds/crash.mp3" loop={false} distance={5} />
//   </group>
// )
